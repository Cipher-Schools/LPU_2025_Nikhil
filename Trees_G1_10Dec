// Online C++ compiler to run C++ program online
#include <bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node* left;
    Node* right;
    
    Node(int val){
        data = val;
        left = nullptr;
        right = nullptr;
    }
};



// int sumByDFS(Node* root){
//     if(root==nullptr)return 0;
//     return sumByDFS(root->left)+sumByDFS(root->right) + root->data;
// }

// int sumByBFS(Node* root){
//     queue<Node*>q;
//     q.push(root);
//     int sum = 0;
//     while(!q.empty()){
//         Node* node = q.front();
//         q.pop();
        
//         sum+=node->data;
//         if(node->left)q.push(node->left);
//         if(node->right)q.push(node->right);
//     }
    
//     return sum;
// }

// int countByDFS(Node* root){
//     if(!root)return 0;
//     return 1 + countByDFS(root->left)+countByDFS(root->right);
// }


// int countByBFS(Node* root){
//     queue<Node*>q;
//     q.push(root);
//     int count = 0;
//     while(!q.empty()){
//         Node* node = q.front();
//         q.pop();
        
//         count++;
//         if(node->left)q.push(node->left);
//         if(node->right)q.push(node->right);
//     }
    
//     return count;
// }

// int countOfLeafNode(Node* root){
//     if(!root)return 0;
//     if(root->left==nullptr && root->right ==nullptr)return 1;
//     // return countOfLeafNode(root->left) + countOfLeafNode(root->right);
    
//     int leftCount = countOfLeafNode(root->left) ;
//     int rightCount = countOfLeafNode(root->right);
    
//     return leftCount + rightCount;
    
// }

// void countOfNonLeafNodeByDFS1(Node* root,int &count){
//     if(!root)return ;
//     if(root->left!=nullptr || root->right !=nullptr)count++;

//      countOfLeafNode(root->left,count) ;
//      countOfLeafNode(root->right,count);
    
// }


// int countOfNonLeafNodeByDFS(Node* root){
//     if(!root)return 0 ;
    
//     int count = 0;
//     if(root->left!=nullptr || root->right !=nullptr)count++;

//     return count +  countOfNonLeafNodeByDFS(root->left)+ countOfNonLeafNodeByDFS(root->right);
// }



// int countOfLeafNodeByBFS(Node* root){
//     queue<Node*>q;
//     q.push(root);
//     int count = 0;
//     while(!q.empty()){
//         Node* node = q.front();
//         q.pop();
        
//         if(node->left==nullptr && node->right ==nullptr)count++;
//         if(node->left)q.push(node->left);
//         if(node->right)q.push(node->right);
//     }
    
//     return count;
// }



// int heightByDFS(Node* root){
//     if(!root)return 0;
    
//     int leftHeight = heightByDFS(root->left);
//     int rightHeight = heightByDFS(root->right);
    
//     return 1+max(leftHeight,rightHeight);
    
// }


void printLeftView(Node* root){
    queue<Node*>q;
    q.push(root);
    
    while(!q.empty()){
        int size = q.size();
        
        for(int i = 1;i<=size;i++){
            Node* node = q.front();
            q.pop();
            
            if(i==1)cout<<node->data<<" ";
            
             if(node->left)q.push(node->left);
             if(node->right)q.push(node->right);
            
        }
    }
}

void zigzagTraversal(Node* root){
    queue<Node*>q;
    q.push(root);
    bool leftToRight = true;
    while(!q.empty()){
        int size = q.size();
       
       for(int i =1;i<=size;i++){
           Node* node = q.front();
            q.pop();
            
            cout<<node->data<<" ";
        
            if(leftToRight){
                   if(node->left)q.push(node->left);
                   if(node->right)q.push(node->right); 
            }
            else{
                    if(node->right)q.push(node->right);
                    if(node->left)q.push(node->left);
            }
         
       }
       
       cout<<endl;
       
         leftToRight=!leftToRight;
        // if(leftToRight==false)leftToRight=true;
        // else leftToRight=false;
        
    }
}


int main() {
    
    Node* root = new Node(1);
    Node* leftNode = new Node(2);
    Node* rightNode = new Node(3);
    
    root->left = leftNode ;
    root->right = rightNode;
    
    Node* left1 = new Node(4);
    leftNode->left = left1;
    Node* right1 = new Node(5);
    leftNode->right = right1;
    
   //cout<< countOfNonLeafNodeByDFS(root);
   
  // printLeftView(root);
  
  zigzagTraversal(root);
  

    

    return 0;
}
